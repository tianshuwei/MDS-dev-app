/********************************************************
*                                                       *
*   Copyright (C) Microsoft. All rights reserved.       *
*                                                       *
********************************************************/
"use strict";

var fs = tryRequire('fs'),
    path = tryRequire('path'),
    Q = tryRequire('q'),
    cordova = tryRequire('cordova'),
    res = tryRequire('./lib/resources'),
    hooks = tryRequire('./lib/hooks');

cordova.on('results', console.log);
cordova.on('log', console.log);
cordova.on('warn', console.warn);
cordova.on('verbose', console.log);

// Custom hooks
cordova.on('after_prepare', hooks.afterPrepare);
cordova.on('after_compile', hooks.afterCompile);
// Track when prepare is run.
cordova.on('before_prepare', function () {
    hooks.beforePrepare();
});

// Performance markers. Set writeOutPerfReport to true to write out perf report.
var perfMarkers = new Array();
var writeOutPerfReport = false;

// Parse build settings
var workingDirAtLaunch = process.cwd();
var BuildSettings = tryRequire('./lib/BuildSettings');
var settings = new BuildSettings(workingDirAtLaunch, process.argv);
res.init(settings.language);

var plugin = tryRequire('./lib/plugin'),
    util = tryRequire('./lib/util'),
    rimraf = tryRequire('rimraf');

if (settings.cordovaPlatform === null) {
    console.error(res.getString('UnsupportedPlatform', settings.platform));
    process.exit(1);
}
if (settings.buildCommand !== 'build' && settings.buildCommand !== 'prepare') {
    console.error(res.getString('UnsupportedBuildCommand', settings.buildCommand));
    process.exit(1);
}

settings.writeToConsole();
util.init(settings);

var isBuild = (settings.buildCommand === 'build');

if (isBuild && settings.platform === 'iOS') {
    settings.requireRunPreparePlatform = false;
}

var noOp = function () { };
try {
    Q(util.createDirectoryIfNecessary(settings.bldDir)).
    then(function () { process.chdir(settings.bldDir); }).
    then(validateConfigXmlSync).
    then(createAppIfNecessary).
    then(function () { process.chdir(settings.cordovaAppDir); }).
    then(isBuild ? updateWww : updateConfigXmlSync).
    then(isBuild ? updateRes : noOp).
    then(isBuild ? copyPlatformMergeFiles : noOp).
    then(updatePlatform).
    then(isBuild ? copyNativeFiles : noOp).
    then(updatePlugins).
    then(preparePlatform).
    then(isBuild ? prepareIconsAndSplashscreens : noOp).
    then(isBuild ? copyBuildInfo : noOp).
    then(isBuild ? buildPlatform : noOp).
    then(isBuild ? copyBackToProject : noOp).
    then(isBuild ? copyAppxOutput : noOp).
    then(writeOutPerfReport ? writePerfReport : noOp).
    fail(function (err) {
        util.writeErrorAndExit(1, err.toString());
    }).
    done();
} catch (e) {
    util.writeErrorAndExit(1, res.getString('BuildError', e.message));
}

function tryRequire(name) {
    if (moduleExists(name)) {
        return require(name);
    }
    else {
        // If we can't load resources containing a proper error message, throw a hardcoded string. The content
        // of the fwlink should still be localized.
        if (res && res.getString) {
            console.error(res.getString('ModuleRequireError'));
            process.exit();
        }
        else {
            console.error('ERROR: A module failed to load. Please try clearing the Cordova cache by using Tools > Options > Tools for Apache Cordova > Cordova Tools > Clear Cordova Cache. Alternatively, for details on how to reinstall vs-mda, see http://go.microsoft.com/fwlink/?LinkID=522541');
            process.exit();
        }
    }
}

function moduleExists(name) {
    try {
        require.resolve(name);
        return true;
    }
    catch (e) {
        return false;
    }
}

function prepareIconsAndSplashscreens() {
    util.markPerf(perfMarkers, 'prepareIconsAndSplashscreens');
    
    console.info(res.getString('CopyingIconsAndSplashscreens', settings.cordovaPlatform));
    var icons = path.join('res', 'icons', settings.cordovaPlatform);
    var splash = path.join('res', 'screens', settings.cordovaPlatform);
    var to;
    if (settings.cordovaPlatform == 'windows') {
        // We need to be backward compatible with old project templates that used 'windows8'
        if (!fs.existsSync(icons)) {
            icons = path.join('res', 'icons', 'windows8');
        }
        if (!fs.existsSync(splash)) {
            splash = path.join('res', 'screens', 'windows8');
        }
        to = path.join('platforms', settings.cordovaPlatform, 'images');
        
        return util.copyRecursive(icons, to, false, []).then(function () {
            return util.copyRecursive(splash, to, false, []);
        });
    }
    else if (settings.cordovaPlatform == 'wp8') {
        to = path.join('platforms', settings.cordovaPlatform);
        
        return util.copyRecursive(icons, to, false, []).then(function () {
            return util.copyRecursive(splash, to, false, []);
        });
    }
    else if (settings.cordovaPlatform == 'android') {
        to = path.join('platforms', settings.cordovaPlatform, 'res');
        util.updateOrRemoveTargetFile(path.join(icons, 'icon-36-ldpi.png'), path.join(to, 'drawable-ldpi', 'icon.png'));
        util.updateOrRemoveTargetFile(path.join(icons, 'icon-48-mdpi.png'), path.join(to, 'drawable-mdpi', 'icon.png'));
        util.updateOrRemoveTargetFile(path.join(icons, 'icon-72-hdpi.png'), path.join(to, 'drawable-hdpi', 'icon.png'));
        util.updateOrRemoveTargetFile(path.join(icons, 'icon-96-xhdpi.png'), path.join(to, 'drawable-xhdpi', 'icon.png'));
        util.updateOrRemoveTargetFile(path.join(icons, 'icon-96-xhdpi.png'), path.join(to, 'drawable', 'icon.png'));
        util.updateOrRemoveTargetFile(path.join(splash, 'screen-xhdpi-landscape.png'), path.join(to, 'drawable-land-xhdpi', 'screen.png'));
        util.updateOrRemoveTargetFile(path.join(splash, 'screen-hdpi-landscape.png'), path.join(to, 'drawable-land-hdpi', 'screen.png'));
        util.updateOrRemoveTargetFile(path.join(splash, 'screen-mdpi-landscape.png'), path.join(to, 'drawable-land-mdpi', 'screen.png'));
        util.updateOrRemoveTargetFile(path.join(splash, 'screen-ldpi-landscape.png'), path.join(to, 'drawable-land-ldpi', 'screen.png'));
        util.updateOrRemoveTargetFile(path.join(splash, 'screen-xhdpi-portrait.png'), path.join(to, 'drawable-port-xhdpi', 'screen.png'));
        util.updateOrRemoveTargetFile(path.join(splash, 'screen-hdpi-portrait.png'), path.join(to, 'drawable-port-hdpi', 'screen.png'));
        util.updateOrRemoveTargetFile(path.join(splash, 'screen-mdpi-portrait.png'), path.join(to, 'drawable-port-mdpi', 'screen.png'));
        util.updateOrRemoveTargetFile(path.join(splash, 'screen-ldpi-portrait.png'), path.join(to, 'drawable-port-ldpi', 'screen.png'));
    }
    
    return Q();
}

function isPlatformLocallySupported(platformArg) {
    return platformArg !== 'ios' || process.platform === 'darwin';
}

function createAppIfNecessary() {
    util.markPerf(perfMarkers, 'createAppIfNecessary');
    
    if (!fs.existsSync(path.join(settings.cordovaAppDir, 'www'))) {
        console.info(res.getString('CreatingApp', settings.cordovaAppDir));
        return cordova.raw.create(settings.cordovaAppDir);
    } else {
        console.info(res.getString('AppDirAlreadyExists', settings.cordovaAppDir));
    }
}

function updateWww() {
    util.markPerf(perfMarkers, 'updateWww');
    
    console.info(res.getString('CopyingAppFilesToWww'));
    
    var fileNameEndingExclusions = util.getDefaultFileNameEndingExclusions().concat([settings.projectSourceDir + '/AppPackages']);
    
    return util.copyRecursive(settings.projectSourceDir, 'www', true, fileNameEndingExclusions)
        .then(function () {
        return util.moveRecursive(path.join('www', 'config.xml'), 'config.xml', false);
    })
        .then(function () {
        console.info(res.getString('DoneCopyingAppFilesToWww'));
    });
}

// For Ripple we do not need to copy all www files. Just deal with the config.xml file.
function updateConfigXmlSync() {
    util.markPerf(perfMarkers, 'updateConfigXmlSync');
    
    var buf = fs.readFileSync(path.join(settings.projectSourceDir, 'config.xml'));
    fs.writeFileSync('config.xml', buf);
}

function validateConfigXmlSync() {
    util.markPerf(perfMarkers, 'validateConfigXmlSync');
    
    var configXmlPath = path.join(settings.projectSourceDir, 'config.xml');
    if (fs.existsSync(configXmlPath)) {
        var doc = util.parseElementtreeSync(configXmlPath);
        var nameElement = doc.find('name');
        var name = (nameElement && nameElement.text) || '';
        var re = /^\s*(((((\d+>)?[a-zA-Z]?:[^:]*)|([^:]*)):)|())(()|([^:]*? ))(error|warning)( \s*[^: ]*)?\s*:.*$/gi
        if (name.match(re)) {
            throw new Error(res.getString('ConfigXmlInvalidNameElement', name));
        }
    }
}

function updateRes() {
    util.markPerf(perfMarkers, 'updateRes');
    
    console.info(res.getString('CopyingResFiles'));
    var from = path.join(settings.projectSourceDir, 'res');
    if (fs.existsSync(from)) {
        var to = 'res';
        util.createDirectoryIfNecessary(to);
        return util.copyRecursive(from, to, true)
                .then(function () {
            console.info(res.getString('DoneCopyingResFiles'));
        });
    } else {
        console.info(res.getString('NoResFilesToCopy', from));
    }
}

function updatePlatform() {
    util.markPerf(perfMarkers, 'updatePlatform');
    
    var cordovaPlatform = settings.cordovaPlatform;
    
    if (!isBuild && cordovaPlatform === 'ios') {
        console.info(res.getString('PreparingRippleForiOS'));
        cordovaPlatform = 'android';
    }
    
    if (isPlatformLocallySupported(cordovaPlatform)) {
        if (!fs.existsSync(path.join('platforms', cordovaPlatform))) {
            if (cordovaPlatform === 'wp8') {
                cordovaPlatform = 'wp8@3.7.1';
            }

            console.info(res.getString('AddingPlatform', cordovaPlatform));
            return cordova.raw.platform('add', cordovaPlatform);
        } else {
            console.info(res.getString('PlatformAlreadyExists', cordovaPlatform));
        }
    }
}

function updatePlugins() {
    util.markPerf(perfMarkers, 'updatePlugins');
    
    console.info(res.getString('UpdatingPlugins'));
    var promisePluginOperations = Q();
    
    var pluginCordovaPlatform = settings.cordovaPlatform;
    
    if (!isBuild && pluginCordovaPlatform === 'ios') {
        pluginCordovaPlatform = 'android';
    }
    
    plugin.init(settings, pluginCordovaPlatform);
    
    // read /plugins/platform.json
    // get "installed_plugins" (IPs) and "dependent_plugins" (DPs)
    // foreach IP in IPs
    //   parse "version" out of /plugins/IP/package.json
    // get list of plugins from config.xml (CPs)
    // remove plugins from IPs whose name@version is not in CPs
    // add CPs that are not in IPs or the DPs

    var localPlugins = [];
    var localNames = [];
    var plugins = plugin.parsePluginsFromConfigSync(path.join(settings.projectSourceDir, 'config.xml'));
    promisePluginOperations = promisePluginOperations.then(function () {
        return plugin.updateLocalPlugins(localPlugins, localNames, plugins);
    });
    
    // Installing local plugins has to happen completely before moving on
    promisePluginOperations = promisePluginOperations.then(function () {
        var dependentPlugins = [];
        var dependentNames = [];
        var installedPlugins = [];
        var installedNames = [];
        var result = Q();
        
        plugin.parseInstalledPlugins(installedPlugins, installedNames, dependentPlugins, dependentNames);
        
        console.info(res.getString('CurrentInstalledPlugins', installedPlugins.toString()));
        console.info(res.getString('CurrentDependentPlugins', dependentPlugins.toString()));
        console.info(res.getString('CurrentConfiguredPlugins', plugins.plugins.toString()));
        
        installedPlugins.forEach(function (p) {
            var pluginNameWithoutVersion = plugin.stripVersionFromPluginName(p);
            
            if (plugins.plugins.indexOf(p) === -1 &&
                plugins.plugins.indexOf(pluginNameWithoutVersion) === -1 &&
                localPlugins.indexOf(p) === -1 &&
                localNames.indexOf(pluginNameWithoutVersion) === -1) {
                result = result.then(function () {
                    console.info(res.getString('RemovingPlugin', pluginNameWithoutVersion));
                    return plugin.removePlugin(pluginNameWithoutVersion);
                });
            }
        });
        
        plugins.plugins.forEach(function (p) {
            var thisParam = plugins.params.shift();
            var pluginNameWithoutVersion = plugin.stripVersionFromPluginName(p);
            // If the user doesn't have a version number in the config.xml file, we should detect
            // a match even if we have a version number for the installed one.  Match p from
            // the config.xml against the list with and without versions.
            if (installedPlugins.indexOf(p) === -1 && dependentPlugins.indexOf(p) === -1 &&
                localPlugins.indexOf(p) === -1 && 
                (p.indexOf('@') !== -1 || (installedNames.indexOf(pluginNameWithoutVersion) === -1 && dependentNames.indexOf(pluginNameWithoutVersion) === -1 &&
                localNames.indexOf(pluginNameWithoutVersion) === -1))) {
                result = result.then(function () {
                    console.info(res.getString('AddingPlugin', p));
                    if (thisParam) {
                        var options = new Array();
                        thisParam.forEach(function (param) {
                            options[options.length] = '--variable';
                            options[options.length] = param;
                        });
                        return cordova.raw.plugin('add', p, { options: options });
                    } else {
                        return cordova.raw.plugin('add', p);
                    }
                });
            }
        });
        
        return result;
    });
    
    return promisePluginOperations;
}

function copyPlatformMergeFiles() {
    util.markPerf(perfMarkers, 'copyPlatformMergeFiles');
    
    util.createDirectoryIfNecessary('merges');
    
    var from = path.join(settings.projectSourceDir, 'merges', settings.cordovaPlatform);
    
    // We need to support the previous 'windows8' merges folder for windows platform as well
    if (!fs.existsSync(from) && settings.cordovaPlatform == 'windows') {
        from = path.join(settings.projectSourceDir, 'merges', 'windows8');
    }
    
    if (!fs.existsSync(from)) {
        return Q();
    }
    var to = path.join('merges', settings.cordovaPlatform);
    
    // The new 'windows' platform still uses 'windows8' for the merges directory
    // BUG: https://msopentech.visualstudio.com/DefaultCollection/Cordova%20-%20Issues/_workitems#_a=edit&id=622
    if (settings.cordovaPlatform == 'windows') {
        to = path.join('merges', 'windows8');
    }
    
    console.info(res.getString('CopyingPlatformMergeFiles', from, to));
    
    return util.copyRecursive(from, to, true)
        .then(function () {
        console.info(res.getString('DoneCopyingPlatformMergeFiles', to));
    });
}

function copyNativeFiles() {
    util.markPerf(perfMarkers, 'copyNativeFiles');
    
    if (isPlatformLocallySupported(settings.cordovaPlatform)) {
        var from = path.join(settings.projectSourceDir, 'res', 'native', settings.cordovaPlatform);
        if (!fs.existsSync(from)) {
            // If res -> native folder isn't here then it could be a project that was created when
            // the res -> cert folder still existed, so check for that location as well.
            from = path.join(settings.projectSourceDir, 'res', 'cert', settings.cordovaPlatform);
            if (!fs.existsSync(from)) {
                return Q();
            }
        }
        
        var to = path.join('platforms', settings.cordovaPlatform);
        console.info(res.getString('CopyingNativeFiles', from, to));
        
        return util.copyRecursive(from, to, false)
            .then(function () {
            console.info(res.getString('DoneCopyingNativeFiles', to));
        });
    }
}


function copyBuildInfo() {
    util.markPerf(perfMarkers, 'copyBuildInfo');
    
    try {
        
        if (settings.cordovaPlatform === 'android') {
            var vsBuildInfoSrc = path.join(settings.platformConfigurationBinDir, 'VSBuildInfo.xml');
            if (fs.existsSync(vsBuildInfoSrc)) {
                var vsBuildInfoDest = path.join('platforms', settings.cordovaPlatform, 'assets', 'www', 'VSBuildInfo.xml');
                util.moveRecursive(vsBuildInfoSrc, vsBuildInfoDest);
            }
        }
        
        if (settings.cordovaPlatform === 'windows') {
            var vsBuildInfoSrc = path.join(settings.platformConfigurationBinDir, 'Microsoft.AppxPackage.Metadata.Overrides.props');
            if (fs.existsSync(vsBuildInfoSrc)) {
                var vsBuildInfoDest = path.join('platforms', settings.cordovaPlatform, 'Microsoft.AppxPackage.Metadata.Overrides.props');
                util.moveRecursive(vsBuildInfoSrc, vsBuildInfoDest);
            }
        }
    }
    catch (ex) {
    }
}

function buildPlatform() {
    util.markPerf(perfMarkers, 'buildPlatform');
    
    if (isPlatformLocallySupported(settings.cordovaPlatform)) {
        console.info(res.getString('BuildingPlatform', settings.cordovaPlatform));
        
        var configurationOptions = '--debug';
        console.info(settings.configuration);
        if (settings.configuration.search(/^Release$/i) !== -1 || settings.configuration.search(/^Distribution/i) !== -1) {
            configurationOptions = '--release';
        }
        
        var buildOptions = '';
        if (settings.platform == 'Windows-AnyCPU') {
            buildOptions = '--archs=anycpu';
        } else if (settings.platform == 'Windows-x64') {
            buildOptions = '--archs=x64';
        } else if (settings.platform == 'Windows-x86') {
            buildOptions = '--archs=x86';
        } else if (settings.platform == 'Windows-ARM') {
            buildOptions = '--archs=arm';
        } else if (settings.cordovaPlatform === 'android') {
            // Set the build to use ant by default
            buildOptions = '--ant';
        }
        
        // Set the target flag to --phone if WP8.1 and --win if Windows
        var windowsTargetOptions = '';
        if (settings.isPlatformPhone81()) {
            windowsTargetOptions = '--phone';
        } else if (settings.cordovaPlatform == 'windows') {
            windowsTargetOptions = '--win';
        }
        
        console.info(res.getString('BuildConfigurationOptions', configurationOptions));
        // build does a prepare, which we don't need because we already called it via 'platform add' or preparePlatform.
        return cordova.raw.compile({ platforms: [settings.cordovaPlatform], options: [configurationOptions, buildOptions, windowsTargetOptions] });
    } else if (settings.buildServerUrl) {
        var remoteBuild = tryRequire('./lib/remoteBuild');
        return remoteBuild.build(settings);
    } else {
        throw new Error(res.getString('RemoteBuildServerNotConfigured'));
    }
}

function preparePlatform() {
    util.markPerf(perfMarkers, 'preparePlatform');
    
    if (!settings.requireRunPreparePlatform) {
        return Q();
    }
    
    console.info(res.getString('PreparingPlatform', settings.cordovaPlatform));
    var platformToPrepare = settings.cordovaPlatform;
    
    if (settings.isRipple() && platformToPrepare === 'ios') {
        platformToPrepare = 'android';
    }
    
    return Q.fcall(function () {
        
        // Used for local Ripple builds. www is renamed to _www because we want the cordova prepare step to be as fast as possible and
        // we only care about what cordova prepare does with plugins for our Ripple build process.
        if (settings.isRipple()) {
            if (fs.existsSync('_www')) {
                rimraf.sync('_www');
            }
            if (fs.existsSync('_merges')) {
                rimraf.sync('_merges');
            }
            
            if (fs.existsSync('www')) {
                fs.renameSync('www', '_www');
            }
            fs.mkdirSync('www');
            if (fs.existsSync('merges')) {
                fs.renameSync('merges', '_merges');
            }
            fs.mkdirSync('merges');
        }
    }).
    then(function () {
        return cordova.raw.prepare({ platforms: [platformToPrepare] });
    }).
    then(function () {
        // Revert the changes for ripple.
        if (settings.isRipple()) {
            rimraf.sync('www');
            fs.renameSync('_www', 'www');
            if (fs.existsSync('_merges')) {
                rimraf.sync('merges');
                fs.renameSync('_merges', 'merges');
            }
        }
    });
}

function copyBackToProject() {
    util.markPerf(perfMarkers, 'copyBackToProject');
    
    console.info(res.getString('CopyingBackToProject', settings.platform));
    
    var copySrc;
    var copyDest = settings.platformConfigurationBinDir;
    util.createDirectoryIfNecessary(copyDest);
    
    if (settings.cordovaPlatform === 'wp8') {
        copySrc = path.join('platforms', settings.cordovaPlatform, 'bin', settings.cordovaConfiguration);
    } else if (settings.cordovaPlatform === 'windows') {
        if (settings.isPlatformPhone81()) {
            copySrc = path.join('platforms', settings.cordovaPlatform, 'build', 'phone', settings.cordovaConfiguration, 'anycpu');
        } else {
            // Adding a plugin with native code will change the build path by adding x64, x86, or ARM.
            // Because of this you can end up with more than one bld path.  The destination
            // directory for this copy is always the same, so just copy the most recent
            
            var directory = util.getWindowsTargetVersion(settings.projectSourceDir);
            
            var src1 = path.join('platforms', settings.cordovaPlatform, 'build', directory, settings.cordovaConfiguration, 'anycpu');
            var src2 = path.join('platforms', settings.cordovaPlatform, 'build', directory, settings.cordovaConfiguration, 'x64');
            var src3 = path.join('platforms', settings.cordovaPlatform, 'build', directory, settings.cordovaConfiguration, 'x86');
            var src4 = path.join('platforms', settings.cordovaPlatform, 'build', directory, settings.cordovaConfiguration, 'ARM');
            var transform = function (s) { return path.join(s, 'AppxManifest.xml'); };
            
            var sources = [src1, src2, src3, src4];
            copySrc = findLatestPath(sources, transform);
        }
    } else if (settings.cordovaPlatform === 'android') {
        copySrc = path.join('platforms', settings.cordovaPlatform, 'ant-build');
    } else {
        return;
    }
    
    return util.copyRecursive(copySrc, copyDest, true, []).then(function () {
        
        if (settings.cordovaPlatform === 'windows') {
            
            console.info(res.getString('CopyingPkgInfoTextFile'));
            
            // Transform generated _pkginfo.txt file
            
            var pkginfoPath = path.join('platforms', settings.cordovaPlatform, 'build', settings.isPlatformPhone81() ? 'phone' : util.getWindowsTargetVersion(settings.projectSourceDir), 'bld', '_pkginfo.txt');
            var pkginfoTargetPath = path.join(settings.binDir, settings.platform, '_pkginfo.txt');

            // Read generated _pkginfo.txt file
            if (fs.existsSync(pkginfoPath)) {
                var platformData = util.parsePlatformValuesFromConfigSync(path.join(settings.projectSourceDir, 'config.xml'), 'windows');
                if (platformData['packageOutputPath']) {
                    var pkgInfoContent = fs.readFileSync(pkginfoPath, { "encoding": "utf-8" });
                    var translatedPath = path.join(platformData['packageOutputPath'], path.basename(path.dirname(pkgInfoContent)), path.basename(pkgInfoContent));
                    fs.writeFileSync(pkginfoTargetPath, translatedPath);
                }
            }
            
            var lastOutDirValues = [
                path.join(settings.projectSourceDir, 'bld', settings.configuration, 'platforms', settings.cordovaPlatform, 'bin', settings.cordovaConfiguration),
                path.join(settings.projectSourceDir, 'bld', settings.configuration, 'platforms', settings.cordovaPlatform, 'bin', 'x86', settings.cordovaConfiguration),
                path.join(settings.projectSourceDir, 'bld', settings.configuration, 'platforms', settings.cordovaPlatform, 'bin', 'x64', settings.cordovaConfiguration),
                path.join(settings.projectSourceDir, 'bld', settings.configuration, 'platforms', settings.cordovaPlatform, 'bin', 'ARM', settings.cordovaConfiguration)];
            
            var outDirFilePath = path.join(settings.binDir, settings.platform, '_outdir.txt');
            var lastOutDirValue = findLatestPath(lastOutDirValues);
            
            if (lastOutDirValue) {
                console.info(res.getString('WritingFromTo', lastOutDirValue, outDirFilePath));
                fs.writeFileSync(outDirFilePath, lastOutDirValue);
            }
        }

    }).then(function () {
        console.info(res.getString('DoneCopyingCompiledFiles', settings.platform));
    }).then(function () {
        if (settings.cordovaPlatform === 'windows') {
            var directory = util.getWindowsTargetVersion(settings.projectSourceDir);
            var cordovaAppxPath = path.join(copyDest, 'CordovaApp.' + directory + '.build.appxrecipe');
            var projectAppxPath = path.join(copyDest, settings.projectName + '.build.appxrecipe');
            console.info(res.getString('CheckingFor', cordovaAppxPath));
            if (fs.existsSync(cordovaAppxPath)) {
                console.info(res.getString('RenamingFromTo', cordovaAppxPath, projectAppxPath));
                fs.renameSync(cordovaAppxPath, projectAppxPath);
            }
        }
    });
}

function findLatestPath(paths, transform) {
    var latestDate = null;
    var latestPath = null;
    for (var i = 0; i < paths.length; i++) {
        var transformedPath = transform ? transform(paths[i]) : paths[i];
        if (fs.existsSync(transformedPath)) {
            var stat = fs.statSync(transformedPath);
            if (!latestDate ||
                stat.mtime.getTime() > latestDate.getTime()) {
                latestDate = stat.mtime;
                latestPath = paths[i];
            }
        }
    }
    
    return latestPath;
}

function copyAppxOutput() {
    util.markPerf(perfMarkers, 'copyAppxOutput');
    
    if (settings.cordovaPlatform === 'windows') {
        console.info(res.getString('CopyingAppxFiles'));
        var platformData = util.parsePlatformValuesFromConfigSync(path.join(settings.projectSourceDir, 'config.xml'), 'windows');
        var packageOutputPath = platformData['packageOutputPath'];
        if (!platformData || !packageOutputPath) {
            console.info(res.getString('NoAppxPackageOutputPath'));
            return Q();
        }
        
        var appxPaths = getAppxPaths();
        util.createDirectoryIfNecessary(packageOutputPath);
        console.info(res.getString('CopyingAppxFilesFromTo', appxPaths['cordovaPackagePath'], packageOutputPath));
        // copy .appxupload file
        return util.copyRecursive(path.join(appxPaths['cordovaPackagePath'], appxPaths['appxUploadFileName']), path.join(packageOutputPath, appxPaths['appxUploadFileName']), false).then(function () {
            // copy package folder
            util.copyRecursive(path.join(appxPaths['cordovaPackagePath'], appxPaths['appxPackagePath']), path.join(packageOutputPath, appxPaths['appxPackagePath']), false).then(function () {
                console.info(res.getString('DoneCopyingAppxFiles'));
            });
        });
    } else {
        // Nothing to do if not windows
        return Q();
    }
}

function getAppxPaths() {
    var paths = {};
    
    var isDebug = (settings.configuration.search(/^Release$/i) === -1 && settings.configuration.search(/^Distribution$/i) === -1);
    var cordovaPackagePath = path.join(settings.cordovaAppDir, 'platforms', 'windows', 'AppPackages');
    
    var appxBasePaths = [];
    var version = getAppliedVersion();
    var suffixList = [
        '_AnyCPU',
        '_x64',
        '_x86',
        '_ARM',
        ''];
    
    var windowsSubPlatformString = '.' + util.getWindowsTargetVersion(settings.projectSourceDir);
    if (settings.isPlatformPhone81()) {
        windowsSubPlatformString = '.Phone';
    }
    
    suffixList.forEach(function (s) {
        var appxBasePath = 'CordovaApp' + windowsSubPlatformString + '_' + version + s;
        if (isDebug) {
            appxBasePath += '_Debug';
        }
        appxBasePaths.push(appxBasePath);
    });

    var appxBase;
    if (settings.isPlatformPhone81()) {
        appxBase = findLatestPath(appxBasePaths, function (s) { return path.join(cordovaPackagePath, s + '_AnyCPU_bundle.appxupload'); });
    } else {
        appxBase = findLatestPath(appxBasePaths, function (s) { return path.join(cordovaPackagePath, s + '.appxupload'); });
    }

    paths['cordovaPackagePath'] = cordovaPackagePath;
    paths['appxPackagePath'] = appxBase + '_Test';
    paths['appxFileName'] = appxBase + '.appx';
    if (settings.isPlatformPhone81()) {
        paths['appxUploadFileName'] = appxBase + '_AnyCPU_bundle.appxupload';
    } else {
        paths['appxUploadFileName'] = appxBase + '.appxupload';
    }
    
    return paths;
}

function getAppliedVersion() {
    var directory = util.getWindowsTargetVersion(settings.projectSourceDir);
    var manifest_path = path.join(settings.cordovaAppDir, 'platforms', 'windows', 'package.' + directory + '.appxmanifest');
    var manifest = util.parseElementtreeSync(manifest_path);
    
    var identityNode = manifest.find('.//Identity');
    if (identityNode) {
        return identityNode['attrib']['Version'];
    }
    
    return '';
}

function writePerfReport() {
    util.markPerf(perfMarkers, 'done');
    console.info(res.getString('PerformanceSummary'));
    console.info(util.generatePerfReport(perfMarkers));
    console.info('-----------------------------------');
}
